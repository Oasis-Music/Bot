// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: soundtrack.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const checkSoundtrackHash = `-- name: CheckSoundtrackHash :one
SELECT 
    s.id, s.title, s.author, s.duration, s.cover_image, s.audio_file, s.is_validated, s.creator_id, s.created_at,
    EXISTS(SELECT True FROM user_soundtrack WHERE soundtrack_id = id AND user_soundtrack.user_id = $2) as attached
FROM soundtrack s 
INNER JOIN soundtrack_hash sh ON sh.hash = $1 AND s.id = sh.soundtrack_id
`

type CheckSoundtrackHashParams struct {
	Hash   string
	UserID int64
}

type CheckSoundtrackHashRow struct {
	ID          int32
	Title       string
	Author      string
	Duration    int16
	CoverImage  sql.NullString
	AudioFile   string
	IsValidated bool
	CreatorID   int64
	CreatedAt   time.Time
	Attached    bool
}

func (q *Queries) CheckSoundtrackHash(ctx context.Context, arg CheckSoundtrackHashParams) (CheckSoundtrackHashRow, error) {
	row := q.db.QueryRow(ctx, checkSoundtrackHash, arg.Hash, arg.UserID)
	var i CheckSoundtrackHashRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Duration,
		&i.CoverImage,
		&i.AudioFile,
		&i.IsValidated,
		&i.CreatorID,
		&i.CreatedAt,
		&i.Attached,
	)
	return i, err
}

const createSoundtrack = `-- name: CreateSoundtrack :one
INSERT INTO soundtrack (
    title,
    author,
    duration,
    cover_image,
    audio_file,
    is_validated,
    creator_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id
`

type CreateSoundtrackParams struct {
	Title       string
	Author      string
	Duration    int16
	CoverImage  sql.NullString
	AudioFile   string
	IsValidated bool
	CreatorID   int64
}

func (q *Queries) CreateSoundtrack(ctx context.Context, arg CreateSoundtrackParams) (int32, error) {
	row := q.db.QueryRow(ctx, createSoundtrack,
		arg.Title,
		arg.Author,
		arg.Duration,
		arg.CoverImage,
		arg.AudioFile,
		arg.IsValidated,
		arg.CreatorID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteSoundtrack = `-- name: DeleteSoundtrack :execrows
DELETE FROM soundtrack WHERE id = $1
`

func (q *Queries) DeleteSoundtrack(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSoundtrack, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getSoundtrack = `-- name: GetSoundtrack :one
SELECT id, title, author, duration, cover_image, audio_file, is_validated, creator_id, created_at, EXISTS
    (SELECT TRUE FROM user_soundtrack WHERE soundtrack_id = id AND user_soundtrack.user_id = $2) AS attached
FROM soundtrack WHERE id = $1
`

type GetSoundtrackParams struct {
	ID     int32
	UserID int64
}

type GetSoundtrackRow struct {
	ID          int32
	Title       string
	Author      string
	Duration    int16
	CoverImage  sql.NullString
	AudioFile   string
	IsValidated bool
	CreatorID   int64
	CreatedAt   time.Time
	Attached    bool
}

func (q *Queries) GetSoundtrack(ctx context.Context, arg GetSoundtrackParams) (GetSoundtrackRow, error) {
	row := q.db.QueryRow(ctx, getSoundtrack, arg.ID, arg.UserID)
	var i GetSoundtrackRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Duration,
		&i.CoverImage,
		&i.AudioFile,
		&i.IsValidated,
		&i.CreatorID,
		&i.CreatedAt,
		&i.Attached,
	)
	return i, err
}

const getSoundtrackByTitle = `-- name: GetSoundtrackByTitle :many
SELECT id, title, author, duration, cover_image, audio_file, is_validated, creator_id, created_at,
	EXISTS(SELECT True FROM user_soundtrack WHERE soundtrack_id = id AND user_soundtrack.user_id = $2) as attached
FROM soundtrack
WHERE to_tsvector(title) @@ to_tsquery($1) LIMIT 10
`

type GetSoundtrackByTitleParams struct {
	ToTsquery string
	UserID    int64
}

type GetSoundtrackByTitleRow struct {
	ID          int32
	Title       string
	Author      string
	Duration    int16
	CoverImage  sql.NullString
	AudioFile   string
	IsValidated bool
	CreatorID   int64
	CreatedAt   time.Time
	Attached    bool
}

func (q *Queries) GetSoundtrackByTitle(ctx context.Context, arg GetSoundtrackByTitleParams) ([]GetSoundtrackByTitleRow, error) {
	rows, err := q.db.Query(ctx, getSoundtrackByTitle, arg.ToTsquery, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoundtrackByTitleRow
	for rows.Next() {
		var i GetSoundtrackByTitleRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Duration,
			&i.CoverImage,
			&i.AudioFile,
			&i.IsValidated,
			&i.CreatorID,
			&i.CreatedAt,
			&i.Attached,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
