package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"oasis/api/internal/delivery/graph/dataloader"
	"oasis/api/internal/delivery/graph/models"
	"oasis/api/internal/entity"
	"oasis/api/internal/services/soundtrack"
	"oasis/api/internal/utils"
	"strconv"
)

// CreateSoundtrack is the resolver for the createSoundtrack field.
func (r *mutationResolver) CreateSoundtrack(ctx context.Context, input models.CreateSoundtrackInput) (bool, error) {
	return r.SoundtrackService.Create(ctx, entity.NewSoundtrackInput{
		Title:      input.Title,
		Author:     input.Author,
		CoverImage: (*entity.Upload)(input.CoverImage),
		Audiofile:  entity.Upload(input.Audiofile),
		Attach:     input.Attach,
	})
}

// DeleteSoundtrack is the resolver for the deleteSoundtrack field.
func (r *mutationResolver) DeleteSoundtrack(ctx context.Context, id string) (bool, error) {
	trackId, err := utils.StrToInt32(id)
	if err != nil {
		return false, errors.New("invalid track id")
	}

	return r.SoundtrackService.Delete(ctx, trackId)
}

// Soundtrack is the resolver for the soundtrack field.
func (r *queryResolver) Soundtrack(ctx context.Context, id string) (models.SoundtrackResult, error) {
	trackId, err := strconv.ParseInt(id, 10, 32)
	if err != nil {
		return nil, errors.New("invalid track id")
	}

	track, err := r.SoundtrackService.Soundtrack(ctx, int32(trackId))
	if errors.Is(err, soundtrack.ErrSoundtrackNotFound) {
		return models.NotFound{
			Message: err.Error(),
		}, nil
	} else if err != nil {
		return nil, err
	}

	soundtrack := models.Soundtrack{
		ID:        utils.IntToString(track.ID),
		Title:     track.Title,
		Author:    track.Author,
		Duration:  track.Duration,
		CoverURL:  utils.StringToNilPtr(track.CoverImage),
		AudioURL:  track.Audio,
		CreatorID: utils.IntToString(track.CreatorID),
		CreatedAt: track.CreatedAt.UTC().String(),
		Attached:  track.Attached,
	}

	return soundtrack, nil
}

// Soundtracks is the resolver for the soundtracks field.
func (r *queryResolver) Soundtracks(ctx context.Context, filter models.SoundtracksFilter) (*models.SoundtracksResponse, error) {
	tracks, err := r.SoundtrackService.AllSoundtracks(ctx, entity.SoundtrackFilter{
		Page: filter.Page,
	})

	if err != nil {
		return nil, err
	}

	soundtracks := make([]models.Soundtrack, 0, len(tracks.Soundtracks))

	for _, track := range tracks.Soundtracks {

		soundtracks = append(soundtracks, models.Soundtrack{
			ID:        utils.IntToString(track.ID),
			Title:     track.Title,
			Author:    track.Author,
			Duration:  track.Duration,
			CoverURL:  utils.StringToNilPtr(track.CoverImage),
			AudioURL:  track.Audio,
			Attached:  track.Attached,
			CreatedAt: track.CreatedAt.UTC().String(),
			CreatorID: utils.IntToString(track.CreatorID),
		})
	}

	return &models.SoundtracksResponse{
		Soundtracks: soundtracks,
	}, nil
}

// SearchSoundtrack is the resolver for the searchSoundtrack field.
func (r *queryResolver) SearchSoundtrack(ctx context.Context, value string) ([]models.Soundtrack, error) {
	nLn := len(value)

	if nLn == 0 {
		return nil, errors.New("invalid value value")
	} else if nLn > 100 {
		return nil, errors.New("invalid value value: max 100")
	}

	tracks, err := r.SoundtrackService.Search(ctx, value)
	if err != nil {
		return nil, err
	}

	var soundtracks []models.Soundtrack

	for _, track := range tracks {

		soundtracks = append(soundtracks, models.Soundtrack{
			ID:        utils.IntToString(track.ID),
			Title:     track.Title,
			Author:    track.Author,
			Duration:  track.Duration,
			CoverURL:  utils.StringToNilPtr(track.CoverImage),
			AudioURL:  track.Audio,
			Attached:  track.Attached,
			CreatedAt: track.CreatedAt.UTC().String(),
			CreatorID: utils.IntToString(track.CreatorID),
		})
	}

	return soundtracks, nil
}

// CheckAudioHash is the resolver for the checkAudioHash field.
func (r *queryResolver) CheckAudioHash(ctx context.Context, hash string) (models.SoundtrackResult, error) {
	track, err := r.SoundtrackService.CheckHash(ctx, hash)
	if errors.Is(err, soundtrack.ErrSoundtrackNotFound) {
		return models.NotFound{
			Message: err.Error(),
		}, nil
	} else if err != nil {
		return nil, err
	}

	soundtrack := models.Soundtrack{
		ID:        utils.IntToString(track.ID),
		Title:     track.Title,
		Author:    track.Author,
		Duration:  track.Duration,
		CoverURL:  utils.StringToNilPtr(track.CoverImage),
		AudioURL:  track.Audio,
		CreatorID: utils.IntToString(track.CreatorID),
		CreatedAt: track.CreatedAt.UTC().String(),
		Attached:  track.Attached,
	}

	return soundtrack, nil
}

// Creator is the resolver for the creator field.
func (r *soundtrackResolver) Creator(ctx context.Context, obj *models.Soundtrack) (*models.User, error) {
	return dataloader.For(ctx).GetUser(ctx, obj.CreatorID)
}

// Soundtrack returns SoundtrackResolver implementation.
func (r *Resolver) Soundtrack() SoundtrackResolver { return &soundtrackResolver{r} }

type soundtrackResolver struct{ *Resolver }
