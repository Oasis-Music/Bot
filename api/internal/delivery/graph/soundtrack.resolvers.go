package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"errors"
	"oasis/api/internal/delivery/graph/dataloader"
	"oasis/api/internal/delivery/graph/models"
	"oasis/api/internal/entity"
	soundtrackServices "oasis/api/internal/services/soundtrack"
	"oasis/api/internal/utils"
)

// CreateSoundtrack is the resolver for the createSoundtrack field.
func (r *mutationResolver) CreateSoundtrack(ctx context.Context, input models.CreateSoundtrackInput) (bool, error) {
	return r.SoundtrackService.Create(ctx, entity.NewSoundtrackInput{
		Title:      input.Title,
		Author:     input.Author,
		CoverImage: (*entity.Upload)(input.CoverImage),
		Audiofile:  entity.Upload(input.Audiofile),
		Attach:     input.Attach,
	})
}

// DeleteSoundtrack is the resolver for the deleteSoundtrack field.
func (r *mutationResolver) DeleteSoundtrack(ctx context.Context, id string) (bool, error) {
	trackId, err := utils.StrToInt32(id)
	if err != nil {
		return false, errors.New("invalid track id")
	}

	return r.SoundtrackService.Delete(ctx, trackId)
}

// Soundtrack is the resolver for the soundtrack field.
func (r *queryResolver) Soundtrack(ctx context.Context, id string) (models.SoundtrackPayload, error) {
	soundtrackID, err := parseSoundtrackID(id)
	if err != nil {
		return nil, err
	}

	soundtrack, err := r.SoundtrackService.Soundtrack(ctx, soundtrackID)
	if err != nil {
		if errors.Is(err, soundtrackServices.ErrSoundtrackNotFound) {
			return models.NotFound{
				Message: err.Error(),
			}, nil
		}
		return nil, err
	}

	return buildSoundtrackModelV2(soundtrack), nil
}

// Soundtracks is the resolver for the soundtracks field.
func (r *queryResolver) Soundtracks(ctx context.Context, filter models.SoundtracksFilter) (*models.SoundtracksResponse, error) {
	tracks, err := r.SoundtrackService.AllSoundtracks(ctx, entity.SoundtrackFilter{
		Page: filter.Page,
	})

	if err != nil {
		return nil, err
	}

	soundtracks := make([]models.Soundtrack, 0, len(tracks.Soundtracks))

	for _, track := range tracks.Soundtracks {
		soundtracks = append(soundtracks, buildSoundtrackModel(track))
	}

	return &models.SoundtracksResponse{
		Soundtracks: soundtracks,
	}, nil
}

// SearchSoundtrack is the resolver for the searchSoundtrack field.
func (r *queryResolver) SearchSoundtrack(ctx context.Context, value string) ([]models.Soundtrack, error) {
	nLn := len(value)

	if nLn == 0 {
		return nil, errors.New("invalid value value")
	} else if nLn > 100 {
		return nil, errors.New("invalid value value: max 100")
	}

	tracks, err := r.SoundtrackService.Search(ctx, value)
	if err != nil {
		return nil, err
	}

	soundtracks := make([]models.Soundtrack, 0, len(tracks))

	for _, track := range tracks {
		soundtracks = append(soundtracks, buildSoundtrackModel(track))
	}

	return soundtracks, nil
}

// CheckAudioHash is the resolver for the checkAudioHash field.
func (r *queryResolver) CheckAudioHash(ctx context.Context, hash string) (models.SoundtrackResult, error) {
	track, err := r.SoundtrackService.CheckHash(ctx, hash)
	if errors.Is(err, soundtrackServices.ErrSoundtrackNotFound) {
		return models.NotFound{
			Message: err.Error(),
		}, nil
	} else if err != nil {
		return nil, err
	}

	return buildSoundtrackModel(*track), nil
}

// Creator is the resolver for the creator field.
func (r *soundtrackResolver) Creator(ctx context.Context, obj *models.Soundtrack) (*models.User, error) {
	return dataloader.For(ctx).GetUser(ctx, obj.CreatorID)
}

// Soundtrack returns SoundtrackResolver implementation.
func (r *Resolver) Soundtrack() SoundtrackResolver { return &soundtrackResolver{r} }

type soundtrackResolver struct{ *Resolver }
